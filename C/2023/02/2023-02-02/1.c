#include <stdio.h>
#include <stdbool.h>

int arr[10] = {0, };                              // 1부터 N까지이니, 마음편하게 10개의 배열을 선언하였다.
bool isusedArr[10] = {false,};                    // 해당 숫자의 중복 여부를 위해 사용했는지 안했는지를 파악할 같은 크기의 배열을 하나 더 선언했다.
int N;                                            // 재귀에서 사용하지만 그 숫자가 변하지는 않는 변수를 전역변수로 선언하였다.
int M;                                            // 재귀에서 사용하지만 그 숫자가 변하지는 않는 변수를 전역변수로 선언하였다.

void Solve(int k){                                // 재귀함수가 사용되는 동안 사용될 depth 를 여기선 k로 표현하고 있다. 
    if(k == M){                                   // 해당 재귀함수는 k가 계속 증가하며, k == M 일때 멈추는 구조를 가지고 있다.
        for (int i = 0; i < M; i++){              // 종료될 때, 수행해야할 내용은 "출력"이므로, 출력을 하고 있다.
            printf("%d ", arr[i]);
        }
        printf("\n");                             // 엔터를 출력하고 있다.
	return;                                   // 마지막에 수행해야할 내용들을 다 수행했으면 return 으로 함수를 종료한다.
    }
    
    for (int i = 1; i <= N; i++){                 // 재귀함수가 종료시점이 아니라면 for 문을 통해 재귀를 진행한다.
        if(!isusedArr[i]){                        // 가지치기할 내용을 찾고있다. 이번 같은 경우는 중복을 없애기 위해 다음과 같이 적용하고 있다.
            arr[k] = i;                           // arr[k] 에 i를 사용하고 있다.
            isusedArr[i] = true;                  // 사용하니까, 사용했음을 표시하고 있다.
            Solve(k+1);                           // 여기에서 재귀가 계속 반복되고 있다. k는 자릿수로 계속 증가하다가, k == M일 때 종료돨 것이다.
            isusedArr[i] = false;                 // 다음 DFS 를 위해 다시 사용하지 않았으로 바꿔주고 있다.
        }
    }
}

int main(){
    scanf("%d %d", &N, &M);                       // 함수의 시작이다. N과 M을 입력받고 있다.
    Solve(0);                                     // 재귀함수의 시작이다. 0부터 시작하고 있다.
}
